---
title: "엔티티 매니저와 영속성 컨텍스트는 뭘까?"
description: "엔티티 매니저와 영속성 컨텍스트는 뭘까? 어떤 관계가 있을까?"
createdAt: '2023-09-26T22:43:00.000Z'
updatedAt: '2023-10-05T00:37:00.000Z'
preview: null
draft: false
tags:
  - tutorial
  - jpa
category: JPA
---

코드를 보여주지 않는, 개념을 탐구하는 글이다. 김영한의 "자바 ORM 표준 JPA 프로그래밍" 책을 기반으로 공부했으나, 좀 더 정확한 개념 파악을 위해 공식 명세, 문서를 주로 찾아보고 정리했다.


# 엔티티
 - 비즈니스 요구사항을 모델링한 객체인 엔티티

# 엔티티 매니저
**엔티티 매니저**는 엔티티를 저장하고, 수정하고, 삭제하고, 조회하는 등 **엔티티와 관련된 모든 일을 처리**한다.
엔티티를 관리하는 **가상의 데이터베이스**로 생각하면 편하다. 엔티티 매니저는 **영속성 컨텍스트와 1대1 관계**를 가진다.

<Accordian title="정말 1:1 관계인가?">
[JPA 2.1 명세 문서](https://download.oracle.com/otn-pub/jcp/persistence-2_1-fr-eval-spec/JavaPersistence.pdf)의 '7.1 Persistence Context'를 살펴보면,
영속성 컨텍스트의 종류를 컨테이너 관리형와 애플리케이션 관리형으로 나눈다.

 - 컨테이너 관리형 : Java EE 환경의 경우, 보통 한 트랜잭션 내에서 여러 컴포넌트를 호출하는 경우가 많다.
 이때 한 트랜잭션 내에서 같은 영속성 컨텍스트가 공유돼야 하는 경우가 생긴다.
 이를 Java EE 컨테이너가 각 컴포넌트에 엔티티 매니저를 주입해줄 때 같은 영속성 컨텍스트가 전파되도록 한다.
 - 애플리케이션 관리형 : Java EE 환경에서 흔하지 않지만, 같은 트랜잭션 내에서 각 엔티티 매니저들이 독립적인 영속성 컨텍스트를 가져야하는 경우가 있다.
 이때, 애플리케이션에서 직접 엔티티 매니저 팩토리를 통해 엔티티 매니저를 만들고 직접 닫도록 한다. Java SE과 Java EE Application client container 환경에서는 무조건 이 방식만 사용 가능한다.

*요약하자면, Java EE 환경에서는 한 영속성 컨텍스트가 여러 엔티티 매니저에 포함되는 1:N 관계가 될 수 있다. 그러나 Java SE 및 Java EE ACC에서는 1:1 관계만 허용된다.*
</Accordian>

# 영속성 컨텍스트
JPA 명세에 따르면, 영속성 컨텍스트는 영속성 엔티티 인스턴스들의 모음이다.<sup>[1]</sup> 그리고 엔티티의 생명주기를 관리한다.
쉽게 말해, **영속성 컨텍스트**는 **엔티티의 CRUD를 담당**하면서 저장했거나 불러온 엔티티를 기억하는 **1차 캐시 역할**을 한다.

![엔티티 매니저와 영속성 컨텍스트](/posts/tutorials/jpa/3-em-and-persistence-context/em.svg)

## 영속성 컨텍스트는 엔티티를 기억한다.
**컨텍스트는 문맥**이라는 뜻이다.
우리가 사람들이랑 대화를 할 때 한번 나온 얘기를 기억하고 다시 묻지 않는 것처럼 엔티티를 기억하는 것이라고 이해하면 편하다.

**엔티티를 기억하므로** 영속성 컨텍스트가 얻는 **장점**이 있다.

 - **캐싱** : 애플리케이션에서 동일한 엔티티를 여러번 조회시, DB를 거치지 않고도 기억하고 있던 엔티티를 돌려주는 점
 - **더티 체킹**: 캐싱된 엔티티를 활용해 애플리케이션에서 엔티티 변경시 기존과 바뀐 내용이 있는지 파악이 쉬운 점
 - **동일성 보장** : 캐싱 덕분에 같은 엔티티를 여러번 조회해도 동일성을 보장하는 점

## 영속성 컨텍스트는 한꺼번에 SQL을 전달한다.
엔티티를 만들거나 수정하거나 삭제하기 위해선 트랜잭션을 시작해야한다.
애플리케이션은 엔티티 매니저에게 트랜잭션 시작과 엔티티 반영을 차례로 요청한다.
그러나 **엔티티 매니저는 엔티티의 변경사항을 데이터베이스에 바로 반영하지 않고, 영속성 컨텍스트에 따로 저장**해둔다.
엔티티 매니저에 커밋을 요청해야 변경사항이 한꺼번에 SQL로 변환되어 데이터베이스에 보내지고 커밋된다.

이렇게 **영속성 컨텍스트에 쌓인 엔티티 변경사항을 데이터베이스와 동기화하는 절차**를 **플러시**(flush)라고 한다.<sup>[2]</sup>
이때 영속성 컨텍스트는 엔티티 변경사항을 저장하는 **트랜잭션 내 쓰기 지연 캐시**로써 동작한다.<sup>[3]</sup>
플러시가 일어나는 조건은 위에 언급된 트랜잭션 커밋 외에도 여러 경우가 있다. 이는 엔티티의 생명주기를 다루면서 언급하겠다.

왜 플러시를 사용해 데이터베이스 쓰기를 지연시킬까?
물리적 데이터베이스 **트랜잭션은** 가능하면 할수록 **최대한 짧아야**한다.
**긴 트랜잭션은 락 경합을 발생**시켜 대용량 요청 처리에 불리하다.<sup>[4]</sup>

## 영속성 컨텍스트는 논리적 개념이다.
**영속성 컨텍스트는 단순히 논리적 개념**이다. 실존하지 않는다. 이 말이 헷갈릴 수도 있는데, **쉽게 비유하자면 정치이념과 사랑을 예**로 들 수 있다.
보수주의, 진보주의, 사회주의, 공산주의 등 정치이념은 실존하지 않는다. 그러나 이는 정치인, 정당, 민중으로 표현될 수 있는 개념이다.
사랑은 실존하지 않는다. 그러나 언어적 표현, 육체적 표현 등으로 표현될 수 있는 개념이다.

실제로 JPA의 엔티티 매니저를 상속한 하이버네이트의 `Session` 인터페이스 설명을 보면, 이렇게 적혀져 있다.
영속성 컨텍스트의 **"개념을 나타낸다"라는 표현**을 사용한다.

> [*Interface Session*](https://docs.jboss.org/hibernate/orm/6.3/javadocs/org/hibernate/Session.html)
> 
> Java 애플리케이션과 하이버네이트 사이의 주요 런타임 인터페이스다.
> 논리적 트랜잭션과 연관된 엔티티 인스턴스 집합인 **영속성 컨텍스트의 개념을 나타낸다.**

정리하자면, 트랜잭션 내에서 사용되는 엔티티를 기억하고 그 엔티티의 생명주기를 관리한다면 그건 뭐든 간에 영속성 컨텍스트라고 말할 수 있다.
그리고 엔티티 매니저는 영속성 컨텍스트를 사용할 수 있는 메서드를 제공하는 인터페이스이다.

<Accordian title="개인적인 소감">
영속성 컨텍스트를 처음에 접했을 땐, 눈에 보이지 않는 논리적 개념에 가깝다길래 뭔 소린가 했다.
개념이 꼭 실존해야한다고 잠깐 착각했던 것 같다. 나를 설득하면서 남을 설득할만한 예를 생각해보니, 실존하지 않는 개념도 있었구나 싶었다.
</Accordian>
<Accordian title="Hibernate PersistenceContext 인터페이스">
Hibernate 클래스 중 [`PersistenceContext`](https://docs.jboss.org/hibernate/orm/6.3/javadocs/org/hibernate/engine/spi/PersistenceContext.html)
인터페이스와 그 구현체 [`StatefulPersistenceContext`](https://docs.jboss.org/hibernate/orm/6.3/javadocs/org/hibernate/engine/internal/StatefulPersistenceContext.html)
는 영속성 컨텍스트의 구현체 일까?

내 생각엔 아닐 것 같다. 위 인터페이스는 영속성 엔티티 인스턴스의 모음이자 1차 캐시로써 역할을 하나 엔티티의 생명주기를 관리하지 않는다.
따라서 아니라고 생각한다. 다른 의견이 있거나 더 잘 아시는 분은 댓글 남겨주면 감사하겠다.
</Accordian>

# 엔티티의 생명주기
엔티티는 영속성 컨텍스트에 의해 생명주기가 관리된다. 생명주기는 4가지 상태가 존재한다.

 - **비영속 (new/transient)** : 영속성 컨텍스트와 아무 관련이 없는 상태
 - **영속 (persist)** : 영속성 컨텍스트에 저장이 되어 관련이 있는 상태
 - **준영속 (detached)** : 영속 상태였다가 영속성 컨텍스트와 더 이상 아무 관련이 없어진 상태
 - **삭제 (removed)** : 영속성 컨텍스트에 관련이 있는 상태, 트랜잭션 커밋이 일어나면 삭제가 되는걸 기다리는 상태다.

즉, 영속성 컨텍스트와 관련이 있는지 없는지(기억하고 있는지 없는지)로 나눌 수 있다.
 - **관련 있음** : 영속, 삭제
 - **관련 없음** : 비영속, 준영속

엔티티들의 생명주기를 관리하기 위해서는 엔티티 매니저가 제공하는 연산(메서드)을 사용한다. 어떤 연산을 사용해 각 상태로 전환할 수 있는지는 아래 그림을 참고하자.

![엔티티 생명주기](/posts/tutorials/jpa/3-em-and-persistence-context/entity-lifecycle.svg)

이 그림으로 알 수 있듯이, 영속성 컨텍스트와 **관련 있는 영속, 삭제 상태는 플러시를 거쳐 데이터베이스와 동기화가 되는 대상**이다.

생명주기에 관련된 글은 또 부가적으로 작성하도록 하겠다.

# 참조
 - [1] : Oracle, ["JSR 338: Java Persistence API, Version 2.1"](https://download.oracle.com/otn-pub/jcp/persistence-2_1-fr-eval-spec/JavaPersistence.pdf), p.63
 - [2] : Oracle, ["JSR 338: Java Persistence API, Version 2.1"](https://download.oracle.com/otn-pub/jcp/persistence-2_1-fr-eval-spec/JavaPersistence.pdf), p.82
 - [3] : Hibernate, ["Hibernate 6.3 User Guide"](https://docs.jboss.org/hibernate/orm/6.3/userguide/html_single/Hibernate_User_Guide.html#flushing), "6. Flushing"
 - [4] : Hibernate, ["Hibernate 6.3 User Guide"](https://docs.jboss.org/hibernate/orm/6.3/userguide/html_single/Hibernate_User_Guide.html#transactions-physical), "8.1. Physical Transactions"
 - 김영한, "자바 ORM 표준 JPA 프로그래밍"